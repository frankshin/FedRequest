<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="fedrequest">FedRequest</h1>
<blockquote>
<p>summary of some font-end request APIS</p>
</blockquote>
<p>目录结构:</p>
<p>— FONT END REQUEST APIS</p>
<p>— XMLHttpRequest</p>
<p>— Fetch</p>
<p>— CROSS DOMAIN</p>
<p>— Ajax规避浏览器同源策略methods</p>
<p>|— 图片ping</p>
<p>|— comet</p>
<p>|— 服务器发送事件(SSE)</p>
<p>|— window.name+iframe</p>
<p>|— window.postMessage()</p>
<p>|— 修改document.domain跨子域</p>
<p>|— 服务器代理</p>
<p>|— JSONP</p>
<p>|— WebSocket</p>
<p>|— SSE与WebSocket</p>
<p>|— CORS</p>
<pre><code>  |— Preflighted Request

  |— Simple Request

  |— Requests with Credential
</code></pre>
<p>— http协议10种请求类型介绍</p>
<pre><code>|— OPTIONS

|— HEAD

|— GET

|— POST

|— PUT

|— DELETE

|— TRANCE

|— CONNECT

|— LINK

|— UNLINK
</code></pre>
<h2 id="font-end-request-apis">FONT-END REQUEST APIS</h2>
<h3 id="xmlhttprequest">XMLHttpRequest</h3>
<blockquote>
<p>XMLHttpRequest是大家普遍比较熟悉的一个浏览器内置对象，所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。</p>
</blockquote>
<h4 id="%E5%8E%86%E5%8F%B2%E5%9B%9E%E9%A1%BE">历史回顾</h4>
<p>1996年，IE 中首先添加了 iframe 用来实现异步请求获取服务器内容
1998年，微软 Outlook 在客户端 script 中实现了 XMLHttp 对象
1999年，微软在 IE5 中添加了 XMLHTTP ActiveX 对象用来异步获取服务器内容，该对象直到 Edge 浏览器才废弃。其它浏览器陆续实现了类似的对象称为 XMLHttpRequest
2004年，Google Gmail 中大量使用 XMLHttpRequest
2005年，Google Map 中大量使用 XMLHttpRequest
2005年，Jesse James Garrett 发表了文章 &quot;Ajax: A New Approach to Web Applications&quot;，Ajax 诞生
2006年，XMLHttpRequest 被 W3C 采纳，最后更新时间是 2014年1月</p>
<h4 id="usage">usage</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// 通过XMLHttpRequest创建请求对象（兼容新老版浏览器）</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createXHR</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> XMLHttpRequest != <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-comment">// &gt; ie7</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XMLHttpRequest();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ActiveXObject != <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-comment">// ie7之前的版本</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">arguments</span>.callee.activeXString != <span class="hljs-string">"string"</span>) {
      <span class="hljs-keyword">var</span> versions = [<span class="hljs-string">"MSXML2.XMLHttp.6.0"</span>, <span class="hljs-string">"MSXML2.XMLHttp.3.0"</span>, <span class="hljs-string">"MSXML2.XMLHttp"</span>],
      i,
      len;
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = versions.length; i &lt; len; i++) {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">new</span> ActiveXObject(versions[i]);
          <span class="hljs-built_in">arguments</span>.callee.activeXString = versions[i];
          <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">catch</span>(ex) {
          <span class="hljs-comment">//  </span>
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-built_in">arguments</span>.callee.activeXString);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'NO XHR object available'</span>);
  }
}
<span class="hljs-comment">// begin request</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendAjax</span>(<span class="hljs-params">method, url, asy</span>) </span>{
  <span class="hljs-keyword">var</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState === <span class="hljs-number">4</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-number">200</span>) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-keyword">this</span>.status);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.response);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"请求失败: "</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-keyword">this</span>.statusText));
      }
    }
  }
  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();
  xhr.onreadystatechange = handler;
  xhr.open(method, url, asy); <span class="hljs-comment">// 规定请求的类型、URL 以及是否异步处理请求</span>
  xhr.responseType = <span class="hljs-string">'json'</span>; <span class="hljs-comment">// 设置该值能够改变响应类型。就是告诉服务器你期望的响应格式。</span>
  xhr.setRequestHeader(<span class="hljs-string">'MyHeader'</span>, <span class="hljs-string">'Myvalue'</span>); <span class="hljs-comment">// 设置自定义头部</span>
  xhr.timeout = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 设置超时时间为1秒，仅适用于IE8+</span>
  xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// code</span>
  }
  xhr.send(params); <span class="hljs-comment">// 将请求发送到服务器 其中send(string)仅用于post请求</span>
}
</div></code></pre>
<h3 id="fetch">Fetch</h3>
<h4 id="%E5%8E%86%E5%8F%B2%E5%9B%9E%E9%A1%BE">历史回顾</h4>
<blockquote></blockquote>
<h4 id="usage">usage</h4>
<blockquote></blockquote>
<h2 id="cross-domain">CROSS DOMAIN</h2>
<h3 id="ajax%E8%A7%84%E9%81%BF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5methods">Ajax规避浏览器同源策略methods</h3>
<h4 id="%E5%9B%BE%E7%89%87ping">图片ping</h4>
<blockquote>
<p>图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而且响应可以是任意内容，但通常是像素图或204响应。通过图像ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，可以知道响应是什么时候接收到的。</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();
img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'success...'</span>);
}
img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'failed...'</span>);
}
img.src = <span class="hljs-string">'xxxxxxxxx'</span>;
</div></code></pre>
<p>图像ping最常用于跟踪用户点击页面或动态广告曝光次数，图像ping有两个主要缺点：</p>
<p>1、只能监听服务端是否相应，不能访问响应的文本；</p>
<p>2、只能发送get请求。</p>
<p>应用demo：利用图像ping可以初略检测网络延迟：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ping</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> statrt = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime()
  <span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image()
  <span class="hljs-keyword">var</span> calcueTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> overtime = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).getTime() - statrt
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ping img的时长：'</span> + overtime)
  }
  img.onload = img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    calcueTime()
  }
  img.src = <span class="hljs-string">'https://www.baidu.com?='</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime().toString();
}

</div></code></pre>
<h4 id="comet">comet</h4>
<p>Comet是Alex Russell发明的一个技术名词，指的是一种基于服务器推送的更高级的Ajax技术，与普通Ajax从页面向服务器请求数据相比，Comet则是由服务器向页面推送数据。</p>
<p>Comet的实现方式有长轮询和流两种：</p>
<p>长轮询：</p>
<p>长轮询类似于传统轮询（短轮询）的升级，浏览器定时发送数据请求，只有有更新的数据时，服务端才会返回数据（如下图21-1，21-2分别为短轮询和长轮询示意图）</p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180301164535057-563650997.jpg" alt="1"></p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180301164632242-40102811.jpg" alt=""></p>
<p>http流：</p>
<p>流不同于长轮询，因为在页面的整个生命周期，只使用一个HTTP连接，就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</p>
<p>在Firefox、safari、opera和chrome中，通过侦听readyStatechange事件及检测readyState的值是否为3，就可以利用xhr对象实现HTTP流。在上述浏览器环境中，随着不断从服务器接收数据，readyState的值会周期性地变为3。当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较之前接收到的数据，决定从什么位置开始取得最新的数据，code如下：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStreamingClient</span>(<span class="hljs-params">url, progress, finished</span>)</span>{
  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(), received = <span class="hljs-number">0</span>
  xhr.open(<span class="hljs-string">'get'</span>, url, <span class="hljs-literal">true</span>);
  xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> result
    <span class="hljs-keyword">if</span>(xhr.readyState === <span class="hljs-number">3</span>){
      result = xhr.responseText.substring(received);
      received += result.length
      <span class="hljs-comment">// 调用progress回调函数</span>
      progress(result)
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(xhr.readyState === <span class="hljs-number">4</span>){
      finished(xhr.responseText)
    }
  }
  xhr.send(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">return</span> xhr;
}
<span class="hljs-comment">// begin call</span>
<span class="hljs-keyword">var</span> api = <span class="hljs-string">'http://baidu.com/xxxxx.xml'</span>
<span class="hljs-keyword">var</span> client = createStreamingClient(api, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>{
    <span class="hljs-built_in">console</span>.log(res)
}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>{
    <span class="hljs-built_in">console</span>.log(res)
})

</div></code></pre>
<h4 id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6sse">服务器发送事件(SSE)</h4>
<blockquote>
<p>SSE是围绕只读Comet交互推出的API或模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是test/event-stream。而且是浏览器中的javascript API能解析格式输出。SSE支持短轮询、长轮询和http流。而且能在断开连接时自动确定何时重新连接。</p>
</blockquote>
<p>支持SSE的浏览器有Firefox6+、Safari5+、Opera11+、Chrome和ios4+版Safari。</p>
<p>1、SSE API</p>
<p>SSE的javascript api与其他传递消息的javascript api很相似。要预定新的时间流，首先要创建一个新的EventSource('myevents.php');</p>
<p>备注：传入的url必须与创建对象的页面同源（url模式、域及端口均相同）。EventSource实例有一个readyState属性，值为0表示正链接到服务器，值为1表示打开了连接，值为2表示关闭了连接。</p>
<p>实例有以下三个事件：</p>
<p>open：在建立连接时触发。</p>
<p>message：在从服务器接收到新事件时触发。</p>
<p>error：在无法建立连接时触发。</p>
<pre class="hljs"><code><div>source.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{
  <span class="hljs-keyword">var</span> data = event.data;
  <span class="hljs-comment">// 数据处理</span>
}
</div></code></pre>
<p>EventSource默认会保持与服务器的活动连接，如果连接断开，还会重新连接。如果需要强制断开连接且不再重新连接，可以调用close()方法。</p>
<p>source.close()</p>
<p>2、事件流</p>
<p>服务器事件会通过一个持久的HTTP响应发送，找个响应的MIME类型为text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data：。例如</p>
<p>data：foo</p>
<p>data：bar</p>
<p>data：foo</p>
<p>data：bar</p>
<p>以上响应中，事件流的第一个message事件返回的event.data值为“foo”，第二个message事件返回的event.data值为“bar”，第三个message事件返回的event.data值为“foo\nbar”（注意中间的换行符）。对于多个连续的以data：开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有在包含data：的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘记多添加这一行。</p>
<p>通过id：前缀可以给特定的事件指定一个关联的ID，找个id行位于data：行前面或后面皆可：</p>
<p>data：foo</p>
<p>id：1</p>
<p>设置了id后，EventSource对象会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为last-event-id的特殊http头部请求，以便服务器知道下一次该触发哪个事件。在对此连接的事件流中，这种机制可以确保浏览器以正确的顺序收到连接的数据段。</p>
<h4 id="windownameiframe">window.name+iframe</h4>
<h4 id="windowpostmessage">window.postMessage()</h4>
<h4 id="%E4%BF%AE%E6%94%B9documentdomain%E8%B7%A8%E5%AD%90%E5%9F%9F">修改document.domain跨子域</h4>
<h4 id="nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86">nginx服务器代理</h4>
<h4 id="jsonp">JSONP</h4>
<h4 id="websocket">WebSocket</h4>
<h4 id="sse%E4%B8%8Ewebsocket">SSE与WebSocket</h4>
<h4 id="cors">CORS</h4>
<p>For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. For example, XMLHttpRequest and the Fetch API follow the same-origin policy. This means that a web application using those APIs can only request HTTP resources from the same origin the application was loaded from, unless the response from the other origin includes the right CORS headers(details see the follows demo).</p>
<p>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as XMLHttpRequest or Fetch to help mitigate the risks of cross-origin HTTP requests.</p>
<p>details here: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a></p>
<h5 id="%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-demo">原理解析 &amp; demo</h5>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/CORS_pri.png" alt=""></p>
<p>Access-Control-Allow-Origin: http://xxxx.com:
该响应头用来记录可以访问该资源的域。在接收到服务端响应后，浏览器将会查看响应中是否包含Access-Control-Allow-Origin响应头。如果该响应头存在，那么浏览器会分析该响应头中所标示的内容。如果其包含了当前页面所在的域，那么浏览器就将知道这是一个被允许的跨域访问，从而不再根据Same-origin Policy来限制用户对该数据的访问</p>
<h5 id="preflighted-request">Preflighted Request</h5>
<p>1、请求类型除GET,HEAD或POST以外的任何一种类型；</p>
<p>2、请求类型POST，Content-Type不是application/x-www-form-urlencoded，multipart/form-data或text/plain之一.</p>
<p>eg:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 首先执行请求代码follows：</span>
<span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest(),
payload = ......;
request.open(<span class="hljs-string">'POST'</span>, <span class="hljs-string">'http://frankshin/someData'</span>, <span class="hljs-literal">true</span>);
request.setRequestHeader(<span class="hljs-string">'TEST-CROESS-HEADER'</span>, <span class="hljs-string">'value'</span>);
request.onreadystatechange = handler;
request.send(payload);

<span class="hljs-comment">// 打开浏览器debug可以看到如下，该阶段相当于在询问服务端是否可以请求数据：</span>
OPTIONS /someData/ HTTP/<span class="hljs-number">1.1</span>
Host: frankshin.com
......
Origin: http:<span class="hljs-comment">//frankshin.com</span>
Access-Control-Request-Method: POST
Access-Control-Request-Headers: TEST-CROESS-HEADER

<span class="hljs-comment">// 服务端相应头：</span>
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
Access-Control-Allow-Origin: http:<span class="hljs-comment">//frankshin.com</span>
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: TEST-CROESS-HEADER

<span class="hljs-comment">// 接着，浏览器会分析这个返回数据（Response Headers）,如果发现是被允许的请求后，浏览器会开始向服务端发送真正的post请求，follows：</span>
POST /someData/ HTTP/<span class="hljs-number">1.1</span>
Host: frankshin.com
TEST-CROESS-HEADER: value
......
[Payload Here]

<span class="hljs-comment">// 服务端接着处理并返回</span>
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
Access-Control-Allow-Origin: http:<span class="hljs-comment">//frankshin.com</span>
Content-Type: application/xml
......
[Payload Here]

</div></code></pre>
<h5 id="simple-request">Simple Request</h5>
<p>1、请求类型是GET，HEAD或POST之一，没有包含任何自定义请求头；</p>
<p>2、使用POST作为请求，该请求的Content-Type是application/x-www-form-urlencoded，multipart/form-data或text/plain之一。</p>
<h5 id="requests-with-credential">Requests with Credential</h5>
<blockquote>
<p>XMLHttpRequest.withCredentials  属性是一个Boolean类型，它指示了是否该使用类似cookies,authorization headers(头部授权)或者TLS客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site Access-Control）请求。在同一个站点下使用withCredentials属性是无效的。如果在发送来自其他域的XMLHttpRequest请求之前，未设置withCredentials 为true，那么就不能为它自己的域设置cookie值</p>
</blockquote>
<p>带凭证的请求相比简单请求和预检请求，在请求发送时多了y用户凭证（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials">withCredentials</a>）</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 带withCredentials的前端请求代码：</span>
<span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();
request.open(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'http://frankshin.com/someData'</span>, <span class="hljs-literal">true</span>);
request.withCredentials = <span class="hljs-literal">true</span>;
request.onreadystatechange = handler;
request.send();

<span class="hljs-comment">// 服务端的返回x响应头</span>
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
Access-Control-Allow-Origin: http:<span class="hljs-comment">//frankshin.com</span>
Content-Type: application/xml
......
[Payload Here]
</div></code></pre>
<p>一个跨域请求包含了当前页面的用户凭证，那么其就属于Requests with Credential（ps：一般情况下，一个跨域请求不会包含当前页面的用户凭证）。</p>
<h3 id="http%E5%8D%8F%E8%AE%AE10%E7%A7%8D%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D">http协议10种请求类型介绍</h3>
<h4 id="options">OPTIONS</h4>
<blockquote>
<p>说明：询问服务器支持的方法,支持的http协议版本: 1.0、1.1</p>
</blockquote>
<h4 id="head">HEAD</h4>
<blockquote>
<p>说明：获得报文首部,支持的http协议版本: 1.0、1.1</p>
</blockquote>
<h4 id="get">GET</h4>
<blockquote>
<p>说明：获取资源,支持的http协议版本: 1.0、1.1</p>
</blockquote>
<p>get的常见参数提交方式为Query String Parameter，如下图：</p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180626185813168-647235402.png" alt=""></p>
<h4 id="post">POST</h4>
<blockquote>
<p>传输实体主体,支持的http协议版本: 1.0、1.1</p>
</blockquote>
<p>HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体，协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以</p>
<h5 id="1-applicationx-www-form-urlencoded">1 application/x-www-form-urlencoded</h5>
<blockquote>
<p>即参数提交方式application/x-www-form-urlencoded</p>
</blockquote>
<p>这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以application/x-www-form-urlencoded方式提交数据，注意，如果写原生的ajax请求，提交的数据需要按照 key1=val1&amp;key2=val2 的方式进行序列化编码，key和val都进行了URL转码（一些库如jquery等其内部已做好了封装，所以不需要进行序列化操作）</p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180626184636340-1356927996.png" alt=""></p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180626184726974-155389537.png" alt=""></p>
<h5 id="2-multipartform-data">2 multipart/form-data</h5>
<blockquote>
<p>即参数提交方式multipart/form-data</p>
</blockquote>
<p>这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<h5 id="3-applicationjson">3 application/json</h5>
<blockquote>
<p>参数提交方式application/json</p>
</blockquote>
<p>用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦，这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口，请求如下图：</p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180626193409703-1342591225.png" alt=""></p>
<p><img src="https://smallpang.oss-cn-shanghai.aliyuncs.com/blog/images/1098800-20180626192143334-1218422902.png" alt=""></p>
<h5 id="4-textxml">4 text/xml</h5>
<blockquote>
<p>即参数提交方式text/xml</p>
</blockquote>
<p>一种使用HTTP作为传输协议，XML作为编码方式的远程调用规范，不过XML结构还是过于臃肿，一般场景用JSON会更灵活方便</p>
<h4 id="put">PUT</h4>
<blockquote>
<p>传输文件, 支持的http协议版本: 1.0、1.1</p>
</blockquote>
<h4 id="delete">DELETE</h4>
<blockquote>
<p>删除文件, 支持的http协议版本: 1.0、1.1</p>
</blockquote>
<h4 id="trance">TRANCE</h4>
<blockquote>
<p>追踪路径,支持的http协议版本: 1.1</p>
</blockquote>
<h4 id="connect">CONNECT</h4>
<blockquote>
<p>要求用隧道协议连接代理,支持的http协议版本: 1.1</p>
</blockquote>
<h4 id="link">LINK</h4>
<blockquote>
<p>说明：建立和资源之间的联系,支持的http协议版本: 1.0</p>
</blockquote>
<h4 id="unlink">UNLINK</h4>
<blockquote>
<p>断开连接关系,支持的http协议版本: 1.0</p>
</blockquote>
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2>
<p><a href="https://www.cnblogs.com/loveis715/p/4592246.html">cors简介</a></p>
<p>《javacript高级程序设计》</p>

</body>
</html>
